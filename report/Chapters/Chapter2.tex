
\chapter{Automating PPR discovery} 
\label{chap:methods}

A brief overview of extraction and comparison

\section{pyHMMER}
\label{ssec:pyHMMER}

The HMMER suite provides all of the basic algorithms required in order to
perform an HMM search on a target amino acid sequence, but it does have some
limitations.

The first is that it is a command line program and does not have bindings to
any programming language.
HMMER reads inputs from files, and writes out tabular output data to file which
would be very time consuming to parse by hand.

HMMER can only compare a protein model with a protein
target, and so the genome must be translated before it can be searched.
There are a total of six possible reading frames (3 forwards and 3 backwards, 
due to the 3:1 nature of translation) and the genome must be searched in each
of these six frames.

HMMER is not commercial software and is developed by a group of scientists at
the Howard Hughes Medical Institute (HHMI) under an open licence for research
purposes.
As such, it contains a number of minor bugs which can sometimes cause problems
under particular circumstances, the most problematic of which causes enormous
memory usage (over 20GB\footnote{One particular instance of this error is due
to an unsigned integer wrap-around which causes significantly more memory to be
requested from the operating system than could possibly be needed}) and
prevents the program from completing.

In order to overcome these issues, a python wrapper for HMMER called
pyHMMER was designed and written.
Python was chosen as the main language for this project mainly because of its
excellent library support -- for example the biopython library solved many of 
the difficulties when working with biological sequences without extra effort.

pyHMMER does not implement all the features available in HMMER, but rather it
implements those which were most vital to this project.
Its main features are -
\begin{itemize}
  \item Read and write \emph{.hmm} files, HMMER's custom file format for
    storing HMMs
  \item Execute searches using 
    \emph{hmmsearch} and \emph{jackhmmer}, accepting all valid command line
    arguments and returning their output as biopython objects, 
    handling the creation and removal of all the necessary 
    temporary files automatically
  \item Seamlessly perform six-frame translations on the fly (implemented in C
    for best performance)
    and map the returned matches to the correct location
  \item Automatically terminate HMMER processes which attempt to allocate more
    memory than the system can sensibly be expected to provide and then call
    HMMER sequentially with subsections of the target\footnote{Linux only}
  \item Fully unit-tested with python's \emph{unittest} framework
\end{itemize}
pyHMMER has been developed under an open-source licence and is freely available
from \emph{https://github.com/haydnKing/pyHMMER}, although all code used in
this project was written by myself.


\section{Automated PPR Detection and Extraction}
\label{sec:ppr_extraction}

Several algorithms were developed and compared in order to extract PPRs from
unannotated genomes.
The results of each algorithm were compared with experimentally validated PPRs
and the best chosen.

Before development could begin, a HMM of the PPR repeat motif was required.
There are four such models available in
Pfam\footnote{http://pfam.sanger.ac.uk/search/keyword?query=PPR}, and each one
was tested on known PPRs in order to discover which model worked best when
searching for motifs.
It was found the PPR\_3 model is most sensitive to the motifs, and still
returns relatively few false positives.

Armed with this model, the final algorithm for discovering PPRs proceeds as
follows for each chromosome within the genome
\begin{enumerate}
  \item \label{alg:first_pass}
    Perform a HMM search on the whole sequence. This will discover the most
    obvious motifs only
  \item \label{alg:grouping}
    Group the motifs into clusters such that motifs which are on the same
    strand and are within a certain distance are put in the same cluster
  \item \label{alg:envelopes} 
    For each group, extract and `envelope' region containing each motif in the
    group along with large margins either side. 
  \item \label{alg:second_pass}
    Search each envelope region for PPR motifs. This search is more
    focussed than the previous one and will reveal more motifs than previously.
    Discard any envelopes which contain only one motif.
  \item Starting from the first position of the first motif, search backwards
    one codon at a time until a start codon (`ATG') is reached
  \item Starting from the last position in the final motif, search forwards one
    codon at a time until a stop codon is reached (`TGA', `TAG' or `TAA').
    Extract the putative PPR from between the start and stop codon
  \item \label{alg:overlap}
    Check for PPRs which overlap. 
    Each set of overlapping proteins should be removed and a new, larger
    envelope extracted. The algorithm then continues again from step
    \ref{alg:second_pass} with only the new envelopes
  \item \label{alg:large_proteins}
    Check for PPRs where the motifs have filled the envelopes -- i.e. ones
    which are missing a start or a stop codon due to not having searched far
    enough. Extract larger envelopes for these proteins and continue from step
    \ref{alg:second_pass}
  \item \label{alg:reluctance}
    Search each protein for gaps between motifs which are the correct size
    to fit a PPR motif. Search these regions specifically, increasing HMMER's
    sensitivity to look for reluctant PPR
    motifs. Also search the beginning and the end of the protein in this way
  \item \label{alg:remove_gaps}
    Search each protein for small (2/3 codon) gaps between the motifs and
    move the end position of the previous motif in order to fill these gaps.
    This allows the motifs to be classified as P, L or S
  \item \label{alg:classification} 
    Classify the proteins depending on which types of motifs they contain.
    Extract the protein sequence of each tail sequence and classify it using
    \emph{jackhmmer} to search for the known consensus sequences for E, E+ and
    DYW motifs
  \item \label{alg:subcellular_location}
    Predict each protein's sub-cellular location using the \emph{targetP}
    program
\end{enumerate}
A brief discussion of the rationale and implementation of the most important 
steps follows.

The reason why the motifs found in step \ref{alg:first_pass} cannot simply be
accepted is due to the degenerate nature of the motifs.
It would be possible to decrease HMMER's reporting threshold as to return all
possible motifs but since the search space is very large, there would be a
large number of false positives.
By using default values for these thresholds there is unlikely to be a problem 
as HMMER is designed to show only the most probable matches and only a few of
the false positives.
The presence of a few false positives at this stage is not an issue because the
chance of finding several false positives immediately adjacent to each other 
(as would be required to pass the later stages of the algorithm) is highly 
unlikely.

Having found the most obvious motifs, step \ref{alg:grouping} groups motifs
which are believed to belong to the same protein.
Initially this was restricted to motifs which were in the same reading frame
(i.e. the gaps between starts were multiples of three), but this was later
expanded to all motifs on the same strand, as introns (see sections
\ref{sec:transcription} and \ref{sec:translation}) are known to be
present in some PPR motifs.
Experiment showed that grouping motifs which were within $1500bp$ of each other
gave good results.
Grouping was implemented by first sorting the motifs into ascending order and 
then searching through linearly giving a cost of $O(n \log n)$ rather than the 
cost of $O(n^2)$ required for exhaustively comparing each motif.

Envelopes are then extracted from these groups in step \ref{alg:envelopes}.
The term `envelope' is borrowed from HMMER's output and refers to the fact that
we expect there to be a PPR somewhere within this region, but we are not sure
where yet.
For envelopes on the reverse strand, the sequence is extracted such that it
reads correctly from left-to-right.
It is important to maintain a record of where in the target sequence the
envelope came from, as this information may be required later in the algorithm.
A margin of $1000bp$ either side of the group was found to give good results.

The search space in step \ref{alg:second_pass} is orders of magnitudes smaller
than the first pass and so the chances of finding a high-scoring match by
chance are negligible.
Shortening the target in this way effectively moves HMMER's baseline for
scoring matches such that lower scoring matches which would previously have 
been written off as noise are now treated as legitimate matches.

Steps \ref{alg:overlap} and \ref{alg:large_proteins} effectively correct for
situations where the parameter values chosen for grouping and envelope
extraction to not perform well.
For example, if step \ref{alg:first_pass} detects the first and last motifs
from a particularly long PPR then these will be treated as belonging to 
separate proteins up until this point.
Similarly, if only one motif was detected then the size of the actual protein
may be larger than the envelope which is extracted.

These two steps introduce loops into the algorithm and thus introduce the
worrying possibility of an infinite loop preventing the algorithm from
completing.
In the case of step \ref{alg:overlap} this is not the case as for each
iteration of the loop the number of putative proteins is half that of the
previous loop, meaning that no infinite loop is possible.
An infinite loop is also impossible in \ref{alg:large_proteins}, as the growth
of the envelope is limited by the size of the search query. 
However, since each loop iteration is expensive and adds only a constant 
length to the envelope this could take quite some time in the worst case.
To protect from this, a large upper bound was placed on the maximum length of 
a protein.

Proteins which are input to step \ref{alg:reluctance} often contain gaps of
around 35 amino acids -- the correct size for a repeat motif -- and comparison
with known proteins shows that a motif should indeed be placed in this region.
These motifs can be found by searching these regions with a lower reporting
threshold than the default.
A plausible explanation of these poorly conserved motifs is that the presence of
relatively well conserved (and thus well folded) regions on either side of the
degenerate motif increases its tendency to fold correctly.
However it could also be the case that these regions simply represent a gap in
the recognition chain (where any base would be accepted) or an intron; more
empirical results are needed in order to determine this.
Setting each of the parameters \emph{F1}, \emph{F2} and \emph{F3} to $0.5$ 
gave a reasonable trade-off between finding likely reclusive motifs and 
rejecting random sequences.

Studies such as \citet{Lurin2004} have shown that tandem PPR repeat motifs tend
not to have small gaps between them.
Since pyHMMER returns the location of the HMMER model, each match is the same
length as the model.
This is corrected for in step \ref{alg:remove_gaps}, such that the motifs can
be classified as type P (length~$=$~35aa), L (length~$>$~35aa) or 
S (length~$<$~35aa).

The final two stages classify the extracted proteins depending on their type
and sub-cellular targeting.
Step \ref{alg:classification} makes use of the \emph{jackhmmer} program which
iteratively constructs HMM models of a consensus sequence based on a target
sequence and is supported by pyHMMER.
The final step uses \emph{targetP}, a well respected prediction algorithm for
sub-cellular localisation\citep{targetP}.

\section{Predicting PPR Binding regions}
\label{sec:ppr_binding_prediction}

Introduce the problem and the data available.

\subsection{Direct HMMs}
\label{sec:hmm_binding}

Explain this method and why it failed

\subsection{PSSM}
\label{sec:pssm_binding}

Explain why this method was more successful, but why it fails to recognise a
precise binding region and how this problem was overcome.


